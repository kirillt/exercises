\documentclass[10pt,pdf,hyperref={unicode}]{beamer}
\usepackage[english,russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{agda}
\usepackage{ucs}

\usetheme{Boadilla}

   \begin{document}

      \title[Proof assistants и семантики]{Использование proof assistants для описания операционных семантик}
      \author[Кирилл Таран]{Кирилл Таран}
      \institute{445 группа}

      \begin{frame}
         \titlepage
         \hfill науч. рук.: Булычев Д.Ю.
      \end{frame}

      \section{О проекте}

      \begin{frame}
         \frametitle{О проекте}
         \begin{itemize}
            \item Исследование в рамках лаборатории JetBrains
            \item Области исследования:
               \begin{itemize}
                  \item разработка языков программирования
                  \item сертификационное программирование
                     \begin{itemize}
                     \item К программе прилагаются ``сертификаты'' -- формальные описания
                      и доказательства её полезных свойств.
                     \end{itemize}
               \end{itemize}
         \end{itemize}
      \end{frame}

      \section{Введение в Proof assistants}

      \begin{frame}
         \frametitle{Введение}
         \framesubtitle{Proof assistants}
         \begin{itemize}
            \item Сертификационное программирование появилось
            в связи с развитием т.н. proof assistants -- систем
            для интерактивного построения доказательств теорем,
            автоматической проверки доказательств и т.д.
            \item В данной работе рассмотрены системы,
            основанные на зависимых типах
         \end{itemize}
      \end{frame}

      \begin{frame}
         \frametitle{Введение}
         \framesubtitle{Зависимые типы}
         \begin{itemize}
            \item ``Зависимые типы'' -- могут быть параметризованы термами (значениями),
             в отличие от простых полиморфных типов, которые могут быть
             параметризованы только другими типами
            \item Язык программирования с зависимыми типами позволяет работать
             с теоремами (Curry--Howard correspondence):
               \begin{itemize}
                  \item формулировка теоремы -- тип функции
                  \item терм, определяющий функцию -- доказательство
               \end{itemize}
         \end{itemize}
      \end{frame}

      \section{Цели работы}

      \begin{frame}
         \frametitle{Цели работы}
         \begin{itemize}
            \item Операционная семантика -- дедуктивная система, поэтому
             инструменты для доказательства теорем могут оказаться полезными при работе с ней
            \item Цель курсовой -- оценить применимость p.a. к задачам разработки языков программирования
            \item Предполагаемые результаты:
            \begin{itemize}
               \item автоматическая генерация интерпретатора по операционной семантике
               \item доказательство каких-либо свойств об интерпретации (по возможности автоматическое)
               \item рассмотреть различные системы (по возможности)
            \end{itemize}
         \end{itemize}
      \end{frame}

      \section{Основная часть}

      \newcommand{\control}[2]{\langle #1, #2 \rangle}
      \newcommand{\rulens}[3]{\control{#1}{#2} \to #3}
      \newcommand{\ruless}[4]{\rulens{#1}{#2}{#3} \frac{#4}{}}
      \newcommand{\tree}[3]{\cfrac{#1 \hspace{10mm} #2}{#3}}

      \begin{frame}
         \frametitle{Операционные семантики}
         \framesubtitle{Семантическое дерево}
         \begin{itemize}
            \item Семантика задаёт переходы между состояниями
            \item Программе соответствует семантическое дерево --
             дерево применений правил семантики к синтаксическим
             элементам программы
             \item Пример дерева:
             \begin{itemize}
                \item[] программа `(z:=x ; x:=y) ; y:=z'
                \newline
                \item[] $\tree{\tree{\rulens{z:=x}{s_0}{s_1}}
                                    {\rulens{x:=y}{s_1}{s_2}}
                                    {\rulens{z:=x;x:=y}{s_0}{s_2}}}
                              {\rulens{y:= z}{s_2}{s_3}}
                              {\rulens{(z:=x ; x:=y) ; y:=z}{s_0}{s_3}}$
                \newline
                \item[] $s_0$, $s_1$, $s_2$ -- состояния программы (списки значений)
             \end{itemize}
         \end{itemize}
      \end{frame}


      \newcommand{\seqns}[0]{\tree{\rulens{p_1}{s_0}{s_1}}{\rulens{p_2}{s_1}{s_2}}{\rulens{p_1 ; p_2}{s_0}{s_2}}}
      \newcommand{\iftruens}[0]{s_0[b] = true\Rightarrow\tree{\rulens{p_1}{s_0}{s_1}}{}
                                                             {\rulens{\mbox{if b then $p_1$ else $p_2$}}{s_0}{s_1}}}
      \newcommand{\assignns}[0]{\rulens{x:=a}{s}{s[x \mapsto a]}}


      \begin{frame}
         \frametitle{Операционные семантики}
         \framesubtitle{Правила вывода (big-step/natural semantics)}

         \begin{align*}
            \begin{tabular}{l || r}
               ``;''       & $\seqns$    \\
               \\ \hline \\
               ``if-true'' & $\iftruens$ \\
               \\ \hline \\
               ``:=''      & $\assignns$ \\
            \end{tabular}
         \end{align*}
      \end{frame}

      \begin{frame}
         \frametitle{Операционная семантика на Agda}
         \framesubtitle{Тип данных}
         \begin{itemize}
            \item Семантика представляется на языке Agda в виде типа данных:
            \begin{itemize}
               \item Термы типа -- семантические деревья
               \item Параметры типа -- входные/выходные состояния перехода и программа
               \item Конструкторы -- правила перехода
            \end{itemize}
            \item[] \small{\input{code/naturaltrans}}
         \end{itemize}
      \end{frame}

      \begin{frame}
         \frametitle{Операционная семантика на Agda}
         \framesubtitle{Тип данных}
         \begin{itemize}
            \item Преимущества подобного представления:
            \begin{itemize}
               \item Задаёт отношение ``вычислимости'', которое можно использовать в типах функций
               \item Кроме результата вычисления интерпретатор будет строить дерево вычисления,
                     которое можно использовать для анализа интерпретатора
               \item Интерпретатор можно попытаться вывести автоматически
            \end{itemize}
            \item[] \small{\input{code/naturaltrans}}
         \end{itemize}
      \end{frame}

      \begin{frame}
         \frametitle{Операционная семантика на Agda}
         \framesubtitle{Интерактивное построение интерпретатора}
            \begin{itemize}
               \item Код, введённый вручную:
               \item[] \footnotesize{\input{code/naturalinterp}}
            \end{itemize} %hack
            \begin{itemize}
               \item Сгенерированный код:
               \item[] \footnotesize{\input{code/naturalinterpfull}}
            \end{itemize}
      \end{frame}

      \begin{frame}
         \frametitle{Операционная семантика на Agda}
         \framesubtitle{Интерактивное построение интерпретатора}
            \begin{itemize}
               \item Автоматический вывод термов решается с помощью Agsy --
                компонента Agda для поиска type inhabitant (auto proof search)
               \item Agsy пытается разобрать по случаям аргументы функции и применить
                данные ему подсказки (леммы), при этом проверяя типизируемость генерируемого выражения
               \item К сожалению, есть ограничения реализации:
                  \begin{itemize}
                     \item сопоставление с образцом произвольных подвыражений
                      Agsy выводить не умеет -- пока что приходится писать вручную
                     \item но возможно получится обойтись функциями специального вида
                      для разбора случаев
                  \end{itemize}
            \end{itemize}
      \end{frame}

      \newcommand{\seqssn}[0]{\tree{\rulens{p_1}{s_0}{s_1}}{}{\ruless{p_1 ; p_2}{s_0}{s_1}{p_2}}}
      \newcommand{\seqssj}[0]{\tree{\ruless{p_1}{s_0}{s_1}{p_1'}}{}
                                   {\ruless{p_1 ; p_2}{s_0}{s_1}{p_1' ; p_2}}}
      \newcommand{\iftruess}[0]{s[b] = true\Rightarrow\ruless{\mbox{if b then $p_1$ else $p_2$}}{s}{s}{p_1}}

      \begin{frame}
         \frametitle{Операционные семантики}
         \framesubtitle{Правила вывода (small-step/structural semantics)}

         \begin{align*}
            \begin{tabular}{c || c}
               ``;''       & \begin{tabular}{c}
                                $\seqssn$ \\
                                \\
                                $\seqssj$
                             \end{tabular} \\
               \\ \hline \\
               ``if-true'' & $\iftruess$ \\
               \\ \hline \\
               ``:=''      & $\assignns$ \\
            \end{tabular}
         \end{align*}
      \end{frame}

      \begin{frame}
         \frametitle{Операционная семантика на Agda}
         \framesubtitle{Интерактивное доказательство свойств}
            \begin{itemize}
               \item Теорема об эквивалентности big-step и small-step семантик:
               \item[] \small{\input{code/equivalence}}
               \item Кода в доказательстве очень много, без автоматического вывода тяжело
            \end{itemize}
      \end{frame}

      \section{Результаты}

      \begin{frame}
          \frametitle{Результаты}
          \begin{itemize}
             \item Найден способ полуавтоматического построения интерпретатора и доказательств свойств о нём
             \item Есть возможность дополнить существующие инструменты до полной автоматизации
             \item Были также рассмотрены Coq и Idris, использующие тактики вместо auto proof search
                \begin{itemize}
                   \item[] $\oplus$  тактики дают больше возможностей по управлению выводом
                   \item[] $\ominus$ но требуют работы по написанию proof script
                \end{itemize}
             \item Репозиторий с кодом:
                \begin{itemize}
                   \item https://github.com/kirillt/exercises/tree/master/semantics
                   \item[] (наброски семантик на Coq, Agda, Idris + интерпретатор на Agda)
                \end{itemize}
          \end{itemize}
      \end{frame}

  \end{document}
