\documentclass[aps,12pt,final,oneside,onecolumn,musixtex,superscriptaddress,centertags]{article} 
\usepackage[colorlinks=true,linkcolor=blue,unicode=true]{hyperref}
\usepackage[english,russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{supertabular}
\usepackage{epigraph}
\usepackage{euscript}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{cite}
\usepackage{agda}
\usepackage{ucs}

\textheight=650pt
\topmargin=-40pt

\newcommand{\ctab}[0]{\indent\indent}
\newcommand{\ctabd}[0]{\ctab\ctab}
\newcommand{\ccode}[1]{\mbox{\texttt{#1}}}

\begin{document}
\sloppy

  \begin{titlepage} 
     \begin{center}
        \textbf{\Large САНКТ-ПЕТЕРБУРГСКИЙ \\ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ} \\[1.0cm]
        \textbf{\large Математико-Механический факультет} \\[0.2cm]
        \textbf{\large Кафедра Cистемного Программирования}\\[3.5cm]

        \textbf{\LARGE Использование proof assistants для описания операционных семантик}\\[1.0cm]
        \textbf{\Large Курсовая работа студента 445 группы} \\[0.2cm]
        \textbf{\Large Тарана Кирилла Сергеевича} \\[3.5cm]

        \begin{flushright} \large \emph{Научный руководитель:} \\ к.ф.-м.н., доцент    \textsc{Булычев Д. Ю.} \end{flushright}
        \begin{flushright} \large \emph{Заведующий кафедрой:}  \\ д.ф.-м.н., профессор \textsc{Терехов А. Н.} \end{flushright}
        \vfill 

        {\large {Санкт-Петербург}} \par
        {\large {2013 г.}}
     \end{center} 
  \end{titlepage}

  \tableofcontents
  \newpage

  \section{Введение}
     В данной работе будут рассмотрены возможности систем для интерактивного доказательство теорем (далее \emph{proof assistants}) применительно к описанию операционных семантик -- дедуктивных систем, описывающих язык программирования.

  \subsection{Предметная область}
     Области, в которых проводится исследование -- разработка языков программирования и сертификационное програмирование.

     \emph{Операционные семантики} позволяют формализовать понятие вычислимости. С их помощью можно реализовывать интерпретаторы, компиляторы, статические анализаторы и прочие программы, необходимые для работы с языками программирования, таким образом, что о них можно рассуждать формально. В свою очередь, формализация разрабатываемого объекта позволяет снизить количество ошибок при реализации, верфицировать полученную программу (т.е. доказать её корректность), а в некоторых случаях и автоматизировать сам процесс разработки.

     В то же время, \emph{сертификационное программирование} -- направление, в котором при разработке программы используются формальные описания и доказательства её полезных или других интересных свойств. Появилось это направление в связи с развитием средств для работы с теоремами (интерактивного доказательства, автоматической проверки и т.д.). Относительно новое поколение таких средств основано на \emph{зависимых типах} и позволяет совместить логику программы и доказательство её корректности в одном коде.

  \subsection{Схожие работы}
     Формализация различных языков программирования произвоилась неоднократно: <примеры>. Есть также и подобные работы, использующие системы для интерактивного доказательства теорем (далее \emph{proof assistants}): <примеры>.

     Данную работу отличает то, что произведётся попытка автоматической генерации интерпретатора по данной операционной семантике языка. <а ещё?>

  \newpage
  \subsection{Цели работы}
     Цель курсовой работы -- оценить применимость proof assistants в области разработки языков программирования.

     Предполагаемые результаты:
     \begin{itemize}
        \item описание операционной семантики с помощью какого-либо proof assistant
        \item автоматическая генерация интерпретатора по операционной семантике (встроенными средствами выбранного инструмента)
        \item доказательство каких-либо свойств об интерпретации (по возможности автоматическое)
        \item рассмотреть различные системы (по возможности)
     \end{itemize}
  \newpage

  \section{Обзор proof assistants}
  \subsection{Зависимые типы}

     \setlength{\epigraphwidth}{10cm}
     \epigraph{Система типов -- это гибко управляемый синтаксический метод доказательства отсутствия в программе определённых видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.}{``Types and Programming Languages''\cite{Pierce:2002:TPL:509043}}

     Механизм \emph{зависимых типов} является расширением параметрического полиморфизма.

     \newcommand{\listtype}[0]{\ccode{List A}} 
     \newcommand{\listcons}[0]{\ccode{cons\hspace{2mm}: A -> List A -> List A}}
     \newcommand{\listnil}[0]{\ccode{nil \hspace{2mm}: List A}}
     \newcommand{\listconst}[0]{
        \ctab\listcons\\
        \ctab\listnil
     }

     При наличии параметрического полиморфизма в языке мы можем работать с типами, параметризованными другими типами. В качестве примера приведу \listtype\:-- тип списка с элементами типа \ccode{A}.

     Код, описывающий конструкторы этого типа:\\
     \listconst
     \newline

     Примером параметрического полиморфизма могут служить также \emph{generics} в Java и С\#. Подробнее про параметричекий полиморфизм можно прочитать в \cite{DBLP:journals/lisp/Strachey00}.

     \newcommand{\vectortype}[0]{\ccode{Vector A (n : N)}}
     \newcommand{\vectorcons}[0]{\ccode{cons\hspace{2mm}: (n : N) -> A -> Vector A n -> Vector A (S n)}}
     \newcommand{\vectornil}[0]{\ccode{nil \hspace{2mm}: Vector A O}}
     \newcommand{\vectorconst}[0]{
     \ctab\vectorcons\\
     \ctab\vectornil\\
     \ctab\ccode{--- S -- конструктор ненулевых натуральных чисел}\\
     \ctab\ccode{--- S n == n + 1}
     }
     \newcommand{\vectorheadtype}[0]{\ccode{(n : N) -> Vector A (S n) -> A}}

     Зависимые же типы могут быть параметризованы не только типами, но и термами (значениями). Классический пример зависимого типа: \vectortype\:-- список фиксированной длины n.

     Код, описывающий конструкторы:\\
     \vectorconst
     \newline

     Возможность использовать термы в качестве типовых параметров позволяет использовать типы как предикаты, а благодаря этому можно использовать предикаты как типы аргументов функций.

     Частично примером может служить функция \ccode{head} с типом \vectorheadtype, возвращающая первый элемент списка типа \ccode{Vector}. Эта функция ожидает в качестве аргумента терм типа \ccode{Vector A (S n)}, что исключает воможность вызвать \ccode{head} от пустого списка.

     Числа \ccode{(S n)} здесь являются конструктивными доказательствами предиката ``список не пуст''. Этот предикат задан неявно, как часть определения типа \ccode{Vector}, но возможно и явное задание в виде обособленного типа вроде \ccode{Predicate (p : proof)} с доказательствами его выполнения в виде элементов типа \ccode{proof}.

     Описания подобных техник можно почерпнуть из \cite{DBLP:conf/tldi/Norell09}.

     \newcommand{\paritydef}[0]{
        \ctab\ccode{data Parity : N -> Set where}\\
        \ctabd\ccode{even\hspace{2mm}: (k : N) -> Parity (k * 2)}\\
        \ctabd\ccode{odd \hspace{2mm}: (k : N) -> Parity (k * 2 + 1)}\\
     }
     \newcommand{\parityusage}[0]{
        \ctab\ccode{f : N -> ...}\\
        \ctab\ccode{f n with parity n --- parity : (n : N) -> Parity n}\\
        \ctab\ccode{f .(k * 2)     | even k = ...}\\
        \ctab\ccode{f .(k * 2 + 1) | odd  k = ...}\\
        \ctab\ccode{--- точка означает автоматически выводимый шаблон}
     }

     Другая техника, доступная благодаря зависимым типам -- \emph{Views}. Она заключается в особом описании типов с параметрами таким образом, что сопоставление элементов этих типов с образцом сообщает дополнительную информацию об элементе-параметре.

     Пример:\\
     \paritydef

     Далее, мы можем использовать элементы типа \ccode{Parity} для некоторого числа n, чтобы разложить аргумент n некоторой функции либо на \ccode{k * 2}, либо на \ccode{k * 2 + 1} в зависимости от значения \ccode{parity} для n:\\
     \parityusage
     \newline

     Далее, эта техника будет использована для описания операционной семантики.
     
  \subsection{Соответствие Карри-Говарда}
     Соответствие Карри-Говарда -- наблюдаемое структурное сходство между компьютерными программами и математическими доказательствами. Главная его идея состоит в том, что любой типизированной системе соответствует некоторя логика, и наоборот.

     Именно благодаря этому соответствию мы можем использовать зависимые типы для выражения условий. На неформальном уровне можно сказать, что высказывания есть типы, а их доказательства являются программами.

     ``В конструктивных логиках доказательство утверждения $P$ состоит в демонстрации конкретного \emph{свидетельства} в пользу $P$. Карри и Говард заметили, что это свидетельство во многом похоже на вычисление. Например, доказательство утверждения $P \Rightarrow Q$ можно рассматривать как механическую процедуру, которая, получая доказательство $P$, строит доказательство $Q$.''\cite{Pierce:2002:TPL:509043}

     \newpage
     В рамках соответствия Карри-Говарда следующие структурные элементы рассматриваются как эквивалентные:
     \begin{align*}
        \begin{tabular}{l || r}
           высказывание $P$                & тип \ccode{P}         \\
           доказательство высказывания $P$ & терм типа \ccode{P}   \\
           утверждение $P$ доказуемо       & тип \ccode{P} обитаем \\
           конъюнкция $P \wedge Q$         & кортеж \ccode{P $\times$ Q} \\
           дизъюнкция $P \vee Q$           & размеченное объединение \ccode{P $+$ Q} \\
           импликация $P \Rightarrow Q$    & функциональный тип \ccode{P $\to$ Q} \\
           истинная формула                & тип с единственным элементом \\
           ложная формула                  & тип без элементов \\
           квантор всеобщности $\forall$   & зависимое произведение $\prod$ \\
           квантор существования $\exists$ & зависимая сумма $\sum$ \\
        \end{tabular}
     \end{align*}

  \newpage
  \subsection{Особенности конкретных систем}
     Прежде чем рассмотреть различные proof assistants, стоит определить понятия \emph{интерактивного} и \emph{автоматического} построения доказательства. \emph{Интерактивным} способом я буду обозначать взаимодействие пользователя с системой на протяжении всего процесса доказательства с направлением доказательства в нужном направлении; а \emph{автоматическим} способом -- взаимодействие, полностью исключающее вмешательство пользователя, кроме формулирования цели (утверждения, теоремы).

  \subsubsection{Coq}
     Одна из самых известных и зрелых систем для интерактивного доказательства теорем -- Coq. Как и все инструменты, рассмотренные в данной работе, Coq использует функциональный язык программирования с зависимыми типами -- Gallina -- для описания структур данных, определения функций и типов.

     Интерактивное и автоматическое доказательство теорем в Coq осуществляется с помощью \emph{тактик} -- программ для обработки контекста доказательства (контекст доказательства содержит переменные-гипотезы подобно контексту вычислений, содержащему переменные-значения). Тактики можно писать на специальном языке Ltac; в добавок, есть встроенная библиотека тактик. Некоторые тактики способны полностью автоматически доказывать теоремы для алгоритмически разрешимых теорий (например, \emph{omega} для арифметики Пресбургера).

     Присутствует автоматизация в автоматическом выводе типов -- можно опускать некоторые типы в сигнатурах функций, которые Coq может вычислить самостоятельно.

     Coq также позволяет разрабатывать и верифицировать программы на основе одного исходного кода благодаря механизму извлечения кода на OCaml, Haskell и Scheme из исходных текстов Coq. При этом, верификационная информация стирается для большей производительности.

  \newpage
  \subsubsection{Agda}
     Система Agda более молодая и имеет меньше средств для автоматизации доказательств.

     В отличие от Coq механизма тактик в Agda нет, как и разделения доказательства на фазы формулировки и собственно доказательства. Вместо этого теоремы определяются как простые функции (из соответствия Карри-Говарда следует, что функции и доказательства теорем суть одно и то же). Однако, отсутствие тактик в некоторой степени компенсируется \emph{рефлексией} в последних версиях системы, т.е. возможностью внутри доказательства обратиться к утверждению.

     Также, в Agda реализована подсистема Agsy для автоматического поиска \emph{type inhabitant}, т.е. значения заданного типа. С помощью неё можно автоматически искать доказательства теорем, но инструмент недостаточно зрелый и имеет ряд ограничений.

     Кроме того, автоматически можно разбивать аргументы функций на конструкторы, что также автоматизирует построение доказательства.

  \subsubsection{Idris}

  \newpage

  \section{Операционные семантики}

    \newcommand{\control}[2]{\langle #1, #2 \rangle}
    \newcommand{\rulens}[3]{\control{#1}{#2} \to #3}
    \newcommand{\ruless}[4]{\rulens{#1}{#2}{#3} \frac{#4}{}}
    \newcommand{\tree}[3]{\cfrac{#1 \hspace{10mm} #2}{#3}}

    \newcommand{\seqns}[0]{\tree{\rulens{p_1}{s_0}{s_1}}{\rulens{p_2}{s_1}{s_2}}{\rulens{p_1 ; p_2}{s_0}{s_2}}}
    \newcommand{\iftruens}[0]{s_0[b] = true\Rightarrow\tree{\rulens{p_1}{s_0}{s_1}}{}
                                                           {\rulens{\mbox{if b then $p_1$ else $p_2$}}{s_0}{s_1}}}
    \newcommand{\assignns}[0]{\rulens{x:=a}{s}{s[x \mapsto a]}}

    \newcommand{\seqssn}[0]{\tree{\rulens{p_1}{s_0}{s_1}}{}{\ruless{p_1 ; p_2}{s_0}{s_1}{p_2}}}
    \newcommand{\seqssj}[0]{\tree{\ruless{p_1}{s_0}{s_1}{p_1'}}{}
                                 {\ruless{p_1 ; p_2}{s_0}{s_1}{p_1' ; p_2}}}
    \newcommand{\iftruess}[0]{s[b] = true\Rightarrow\ruless{\mbox{if b then $p_1$ else $p_2$}}{s}{s}{p_1}}

    Эта глава -- краткое (и менее формальное) переизложение материала книги \cite{Nielson:1992:SAF:129085}.

    \emph{Операционная семантика} задаёт отношение вычислимости некоторой программы на множестве состояний и определяется набором правил вывода.

    Обозначения следующие:
    \begin{align*}
       \begin{tabular}{ p{3cm} || p{10cm} }
          $<S; s> \to  s'$ & программа $S$ переводит состояние $s$ в $s'$ \\
          \hline
          $s[k \mapsto v]$ & модификация состояния $s$                    \\
                           & присвоение значения v переменной k           \\
          \hline
          $\tree{A}{B}{C}$ & составное правило                            \\
                           & A и B -- посылки, а C -- заключение          \\
        \end{tabular}
    \end{align*}

    Пример правил на операционной семантике \emph{большого шага} для тестового языка \large{While}:

    \begin{align*}
       \begin{tabular}{ p{3cm} || p{10cm} }
          seq (``;'')  & $\seqns$    \\
          \hline
          ``if-true''  & $\iftruens$ \\
          \hline
          ass (``:='') & $\assignns$ \\
       \end{tabular}
    \end{align*}

    Здесь \emph{ass}, \emph{skip}, \emph{while-ff} -- элементарные правила, не требующие предпосылок, остальные -- составные.

    Таким образом, каждой программе соответствует \emph{семантическое дерево}, листья которого -- применения элементарных правил, а ветви -- посылки к составным.

    Кроме операционной семантики большого шага (она же \emph{натуральная} семантика) существует понятие операционной семантики \emph{малого шага} или \emph{структурной}. 

    \begin{align*}
       \begin{tabular}{ p{3cm} || p{10cm} }
          seq(``;'')  & 1. $\seqssn$ \\
                      & 2. $\seqssj$ \\
          \hline
          ``if-true'' & $\iftruess$  \\
          \hline
          ass(``:='') & $\assignns$  \\
       \end{tabular}
    \end{align*}

    В отличие от семантики большого шага, теперь мы имеем возможность выделять <...>

  \newpage

  \section{Основная часть}
  \newpage

  \section{Заключение}

  \subsection{Список литературы}
  \bibliographystyle{gost780s}
  \bibliography{literature}

\end{document}
